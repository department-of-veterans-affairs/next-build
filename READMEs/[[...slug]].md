# Understanding `[[...slug]].tsx`

## Background

The file `src/pages/[[...slug]].tsx` is the entry point of static-page generation for all pages built from the CMS. It has its foundation in the [Pages Router in Next.js](https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts). In short, when a file exists in the `pages` directory, it's automatically processed during a static build. Let's dive in deeper to see what exactly that means.

### Wait, but we have a lot of pages we want to build - not just one

That's right. The CMS contains thousands of pages that need to be built by this Next.js project. This `[[...slug]].tsx` file is responsible for building all of them. The keys to making this possible are the brackets and the ellipsis. These are components of a _dynamic_ route. We'll explain those details in a bit, but let's first step back and take a look more generally at how the Pages Router works.

## Pages Router: A Simple Example

Next.js is set up to handle a variety of different build scenarios. In a very simple approach, we might have a site whose pages are entirely pre-determined and constant. Let's consider a site with three pages:

- Homepage
- About Us
- Contact Us

In this case, our `pages` directory might look like this:

```
|__pages
  |__index.tsx
  |__about.tsx
  |__contact.tsx
```

When `next build` (`yarn build`) is executed, Next.js steps through each of these files in the `pages` directory and calls `getStaticProps` in the corresponding file to generate the data needed for that page.

It then passes that data to the template/component defined in that file and builds the HTML for the page at its respective path:

- `index.tsx` => `/`
- `about.tsx` => `/about`
- `contact.tsx` => `/contact`

## The problem

But this isn't the reality of our use case. Our pages are not pre-determined. Rather, our pages are determined by content that can be added/edited/removed by editors in our CMS, which means that _our_ build process needs to first become aware of the paths that it needs to build.

## Pages Router: Our Dynamic Approach

Enter dynamic routes. In our case, we use a single dynamic route as a catch-all for generating all the pages. In the case of dynamic routes, the Pages Router in Next.js requires the implementation of a function `getStaticPaths`, which is called during a static-site build to calculate all the paths for all the pages that need to be built by the template in question. Here's what happens during our build:

1. When a static build is initiated, Next.js (as we saw previously) steps through each of the files in the `pages` directory. In this case, notably, it comes upon `[[..slug]].tsx`.

2. In that file, Next.js finds and calls the `getStaticPaths` function.

3. Inside that function, we ping the CMS for all the content it knows about for _each_ of the content types that we want to build.

4. The entities found for each content type are handled slightly differently. Here are some examples:

   - Most News Story paths map directly to a single path.
   - Lovell Federal News Story paths need to be converted to two paths, one for VA and one for TRICARE (see: [`READMEs/lovell.md`](./lovell.md))
   - Story Listing pages need to have an additional path generated for each subsequent page that needs to be statically built (see: [`READMEs/pagination.md`](./pagination.md))

5. Once all paths are determined for each content type, they are merged together into one large collection.

6. `getStaticProps` is called for each and every entry in the path collection.

7. The data returned from `getStaticProps` is passed to the template to generate an individual page (HTML) for each path.

### So what are the brackets and the ellipsis?

Good question! It seems like we could name this file whatever we want. And that would work just fine if Next.js were _only_ a static-site generator. But it's not. It's also an application server for both prod and dev environments. Consider this:

When we are developing features, rarely would we want to wait for an entire build to finish to see our changes. That would be a painfully slow development process. Instead, by runing `next dev` (`yarn dev`) we can run a development server to build individual pages on demand. But, in order to make this possible, Next.js needs to know which page template to execute. This is where the file naming comes into play.

Let's return to our simple routing example of a site with three pre-determined pages. When building this site, let's say we want to work on the `/about` page. So, we run `yarn dev` and then visit `localhost:3000/about`. When the Next.js development server receives the request for this page, the first thing it will look for is a file in the `pages` directory named `about.tsx`. Since we have one, Next.js will use that file to build the page.

But let's say we _didn't_ have that file. Or, in other words, let's consider _our_ case. Let's say we are working on developing our News Story template. We know that one News Story path is `/minneapolis-health-care/stories/contributing-to-the-future-of-mental-health`. So, again, we run `yarn dev` and then visit `localhost:3000/minneapolis-health-care/stories/contributing-to-the-future-of-mental-health`. Now, the Next.js development server will look inside the `pages` directory for a path corresponding to the url. In this case, it'd first look for a directory named `minneapolis-health-care`, then inside that a directory named `stories` and then a file named `contributing-to-the-future-of-mental-health.tsx`. Of course, we do not have that, so it won't find it. So, then, it starts looking for other "matches". And, as it turns out, it can find "matches" based on wildcards:

- The use of single brackets (e.g. `[slug].tsx`) enables the matching of the current segment. So this would match `localhost:3000/page-1` or `localhost:3000/page-2`. Importantly, it would _not_ match `/minneapolis-health-care/stories/contributing-to-the-future-of-mental-health`.
- The use of an ellipsis (e.g. `[...slug].tsx`) enables the match to be a catch-all match. So, this would match `localhost:3000/page-1` OR `localhost:3000/path/to/page-1`. This _would_ also match `/minneapolis-health-care/stories/contributing-to-the-future-of-mental-health`. Actually, it would match every path _except one_.
- The path we wouldn't match is `localhost:3000` (the homepage). In order to accommodate that, we use double brackets with ellipsis (e.g. `[[...slug]].tsx`), which enables the catch-all segment to be _optional_.

### Considerations

It's useful to point out that we could, conceivably, have multiple files rather than a single `[[...slug]].tsx` file. For example, a site like ours that builds from CMS content might have this structure in its `pages` directory:

```
|__pages
  |__stories
    |__[[...slug]].tsx
  |__events
    |__[[...slug]].tsx
```

Then, we could structure `pages/stories/[[...slug]].tsx` to handle the building of News Story pages, and `pages/events/[[...slug]].tsx` to handle the building of Event pages.

But, importantly, this approach would require that News Story and Event paths all have the wildcard portion at the _end_ of the path (e.g. `/stories/some-story-title` or `/stories/path/to/some-story-title`). In our setup, this is not the case (e.g. we have `/[VAMC system name]/stories/[story-title]`). This structure requires our current approach rather than this alternative.

### From URL to HTML

As we've seen, we accommodate our use case by implementing a single entry point. So, regardless of the URL of the page in question, the same top-level page file is used. We've seen how this single page can be used to match various URLs, but an important question remains: How do we _build_ different types of pages?

There are two main steps:

1. The first step takes place inside `getStaticProps`. When we want to generate HTML for a given URL, we first ping the CMS for more information about the page at that URL. Since the CMS knows the URL for a given page, it can look up the entity based on the URL and provide us important information about the entity. Most importantly, it can tell us what _type_ of entity it represents.

2. Once we know the type of the entity, we can then pass the data object to the appropriate template. We see this at the top of the `[[...slug]].tsx` file in the default export (our top-level page templates inside the `pages` directory need to export a template/component that can generate the HTML for the page).Here, we switch on the entity type, and return the appropriate component. For example, if `entity.type` represents a News Story

And that is basically it! `[[...slug]].tsx` isn't magic, but it is the entry point to the entire process, and it's a critical piece to understanding the architecture of this project.
